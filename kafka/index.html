<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
        <title>聊聊Kafka</title>
        <link rel="stylesheet" href="../markdown.css">
    </head>
    <body>
        <h3>聊聊Kafka</h3>
        <div class="md-display markdown-body"></div>
        <div class="md-txt" style="display:none">

Kafka是一款分布式发布-订阅消息系统，由LinkedIn开发，现在是Apache项目的一部分。常用于**构建实时流数据管道**，在程序之间可靠地获取数据。

首先，我们知：
* Kafka运行在一个集群上，集群分成多个brokers，每一个broker包含若干台机器
* 每条发布到Kafka的消息都有一个类别(topic)
* 每条消息包含一个key, 一个value和一个timestamp

然后，通过Kafka，我们可以：
* 使用**Producer(生产者) API**，发布消息流到一个或多个topic
* 使用**Consumer(消费者) API**，订阅并处理一个或多个topic的消息
* 使用**Streams API**，消费一个输入流，并发布到另一个新的输出流
* 使用**Connector API**，连接一个数据系统(如数据库)至一些topics，实时捕捉这个系统的数据变化

Kafka通过一个简单的、高可用的、语言无关的**TCP协议**连接使用这些API的客户端和Kafka服务端，这个协议是有版本的但保持向后兼容。

### 消息的存储：
&emsp;Kafka用一个topic来表示一组已发布的消息流的名称或者说是类别。一般来说，一个topic会被一个或者多个消费者订阅。  
&emsp;Kafka集群给每个topic维护着一组partition(如下图1)，一条消息只会被分配到其中的一个partition。一个partition内的这些消息按顺序地被添加进来，并分配一个id，实际是偏移量(offset), 不同partition的offset相互不影响。  
![图1](http://upload-images.jianshu.io/upload_images/10223706-6ea9e75b6c2eb00c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  
(图1 | copy from 官网)


&emsp;Kafka会保存所有消息一定的时间，只有当当前的时间比消息上的timestamp超过一定的时长，消息才会被删除，而不是消息是否被消费过。事实上，Kafka并不会记录消息的被消费情况，那是各个消费者自己通过保存一个消费offset来记录的，所以Kafka并不知道消息是否被消费过。但是换个角度想，因为是消费者自己保存offset，所以只要消息还没过期被删除，消费者就可以随机读取，而不需要按顺序消费。  
&emsp;partitions保证了Kafka的高可用性，一易于扩展，partition相互不影响，二增加并发能力。  
&emsp;消费者自己保存offset的设计解耦了Kafka服务与消费者，Kafka是无状态的，消费者可以很容易地接入与离开，因为除了必要的拉取请求外，他完全不会影响到Kafka与其他消费者。  
&emsp;物理存储上，每个partition对应一个逻辑日志，一个日志对应为一组大小相同的分段文件(如下图2)。每次一条消息被分布到一个partition上，Kafka为把消息追加到最后一个分段文件上，当追加到一定数量或者一段固定的时间后，文件会被写入磁盘。写完后，就可以公开到消费者。  
![图2 | copy from infoq](http://upload-images.jianshu.io/upload_images/10223706-a8892d8fe0757dc1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  
(图2 | copy from infoq)


### 分布式
&emsp;所有partition会分布在集群的不同broker节点上。每个partition又会被复制成多份分布在不同的broker节点上，其中一份充当这个partition的Leader节点，剩下的为Follower节点。一旦Leader宕机，会进行选举，从Follower选出新的Leader节点。  
&emsp;Leader维护了这个partition所有的可用Follower的列表，这个列表称为ISR。消息的发布只会通知到的Leader节点，Leader一旦写入日志，Follower就开始拉取进行复制，复制成功后发送ACK到Leader。一旦Follower落后Leader超过一定的延迟时间，Leader就会将这个Follower移除ISR。一条消息能被消费，必需要所有ISR的Follower都确认写入。  
&emsp;一般会结合使用ZooKeeper来实现节点间协调问题。

### 数据的保证

###### 待续...

        </div>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
        <script src="https://cdn.bootcss.com/marked/0.3.12/marked.min.js"></script>
        <script>
            $(document).ready(function(){
                $(".md-display").html(marked($(".md-txt").text()))
            })
        </script>
    </body>
</html>
